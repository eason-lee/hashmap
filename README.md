# Go 语言实现 HashMap

本项目展示了如何使用 Go 语言实现一个基本的 HashMap 数据结构。

## 设计思路

### 1. 基本结构

我们的 HashMap 实现将包含以下核心组件：

- 底层数组（bucket array）：用于存储键值对
- 链表节点：用于解决哈希冲突
- 负载因子：用于控制扩容时机

### 2. 哈希函数

我们将使用 Go 语言内置的 `hash/fnv` 包来实现哈希函数：

- 对于字符串类型的键，直接使用 FNV-1a 哈希算法
- 对于其他类型的键，先将其转换为字符串，再进行哈希

### 3. 冲突解决

采用链地址法（Separate Chaining）来解决哈希冲突：

- 每个桶（bucket）维护一个链表
- 发生冲突时，新元素将被添加到链表末尾
- 查找时遍历链表直到找到目标键或到达末尾

### 4. 动态扩容

为了保持良好的性能，我们将实现动态扩容机制：

- 当负载因子超过阈值（默认0.75）时触发扩容
- 每次扩容将桶数组大小翻倍
- 扩容后重新哈希所有现有元素

## 核心接口

```go
type HashMap interface {
    Put(key interface{}, value interface{})  // 插入/更新键值对
    Get(key interface{}) (interface{}, bool) // 获取值
    Remove(key interface{}) bool             // 删除键值对
    Size() int                              // 获取元素数量
    IsEmpty() bool                          // 检查是否为空
    Clear()                                 // 清空哈希表
}
```

## 实现步骤

1. 定义基本数据结构
   - 创建 `Node` 结构体表示链表节点
   - 创建 `HashMap` 结构体存储基本属性

2. 实现哈希函数
   - 使用 `hash/fnv` 包计算哈希值
   - 实现键的比较方法

3. 实现基本操作
   - Put：插入新键值对
   - Get：获取指定键的值
   - Remove：删除指定键值对

4. 实现动态扩容
   - 监控负载因子
   - 创建新桶数组
   - 重新哈希现有元素

5. 实现辅助方法
   - Size：返回元素数量
   - IsEmpty：检查是否为空
   - Clear：清空哈希表

## 性能特征

在理想情况下，我们的 HashMap 实现将具有以下性能特征：

- 查找：平均 O(1)，最坏 O(n)
- 插入：平均 O(1)，最坏 O(n)
- 删除：平均 O(1)，最坏 O(n)

其中 n 为哈希表中的元素数量。通过合理的哈希函数和动态扩容机制，我们可以在大多数情况下保持接近 O(1) 的性能。

## 使用示例

```go
map := NewHashMap()
map.Put("key1", "value1")
map.Put("key2", "value2")

value, exists := map.Get("key1")
if exists {
    fmt.Println(value) // 输出: value1
}

map.Remove("key1")
fmt.Println(map.Size()) // 输出: 1
```

## 注意事项

1. 哈希函数的选择对性能影响重大，需要确保哈希值分布均匀
2. 负载因子的阈值设置会影响空间使用效率和查询性能
3. 扩容操作可能会暂时影响性能，需要在适当的时机进行

## 后续优化方向

1. 实现并发安全的版本
2. 优化扩容策略，实现渐进式扩容
3. 支持更多类型的键
4. 添加迭代器接口
5. 实现序列化和反序列化